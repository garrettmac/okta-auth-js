{"version":3,"sources":["../../lib/AuthStateManager.ts"],"names":["PCancelable","require","DEFAULT_AUTH_STATE","isPending","isAuthenticated","idToken","accessToken","refreshToken","DEFAULT_PENDING","updateAuthStatePromise","canceledTimes","EVENT_AUTH_STATE_CHANGE","MAX_PROMISE_CANCEL_TIMES","isSameAuthState","prevState","state","JSON","stringify","error","AuthStateManager","constructor","sdk","emitter","AuthSdkError","_sdk","_pending","_authState","_logOptions","tokenManager","on","EVENT_ADDED","key","token","_setLogOptions","event","updateAuthState","EVENT_REMOVED","options","getAuthState","transformAuthState","devMode","autoRenew","autoRemove","getOptions","log","status","group","groupEnd","emitAuthStateChange","authState","emit","shouldEvaluateIsPending","cancel","cancelablePromise","resolve","_","onCancel","shouldReject","emitAndResolve","isCanceled","getTokens","then","hasExpired","promise","Promise","catch","subscribe","handler","unsubscribe","off"],"mappings":"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","sourcesContent":["import { AuthSdkError } from './errors';\nimport { AuthState, AuthStateLogOptions } from './types';\nimport { OktaAuth } from '.';\nimport { getConsole } from './util';\nimport { EVENT_ADDED, EVENT_REMOVED } from './TokenManager';\nconst PCancelable = require('p-cancelable');\n\nexport const DEFAULT_AUTH_STATE = { \n  isPending: true,\n  isAuthenticated: false,\n  idToken: null,\n  accessToken: null,\n  refreshToken: null,\n};\nconst DEFAULT_PENDING = {\n  updateAuthStatePromise: null,\n  canceledTimes: 0\n};\nconst EVENT_AUTH_STATE_CHANGE = 'authStateChange';\nconst MAX_PROMISE_CANCEL_TIMES = 10;\n\n// only compare first level of authState\nconst isSameAuthState = (prevState: AuthState, state: AuthState) => {\n  return prevState.isPending === state.isPending \n    && prevState.isAuthenticated === state.isAuthenticated \n    && JSON.stringify(prevState.idToken) === JSON.stringify(state.idToken)\n    && JSON.stringify(prevState.accessToken) === JSON.stringify(state.accessToken)\n    && prevState.error === state.error;\n};\n\nexport class AuthStateManager {\n  _sdk: OktaAuth;\n  _pending: { \n    updateAuthStatePromise: typeof PCancelable;\n    canceledTimes: number; \n  };\n  _authState: AuthState;\n  _logOptions: AuthStateLogOptions;\n  _lastEventTimestamp: number;\n\n  constructor(sdk: OktaAuth) {\n    if (!sdk.emitter) {\n      throw new AuthSdkError('Emitter should be initialized before AuthStateManager');\n    }\n\n    this._sdk = sdk;\n    this._pending = { ...DEFAULT_PENDING };\n    this._authState = { ...DEFAULT_AUTH_STATE };\n    this._logOptions = {};\n\n    // Listen on tokenManager events to start updateState process\n    // \"added\" event is emitted in both add and renew process\n    // Only listen on \"added\" event to update auth state\n    sdk.tokenManager.on(EVENT_ADDED, (key, token) => {\n      this._setLogOptions({ event: EVENT_ADDED, key, token });\n      this.updateAuthState();\n    });\n    sdk.tokenManager.on(EVENT_REMOVED, (key, token) => {\n      this._setLogOptions({ event: EVENT_REMOVED, key, token });\n      this.updateAuthState();\n    });\n  }\n\n  _setLogOptions(options) {\n    this._logOptions = options;\n  }\n\n  getAuthState(): AuthState {\n    return this._authState;\n  }\n\n  updateAuthState(): void {\n    const { transformAuthState, devMode } = this._sdk.options;\n    const { autoRenew, autoRemove } = this._sdk.tokenManager.getOptions();\n\n    const log = (status) => {\n      const { event, key, token } = this._logOptions;\n      getConsole().group(`OKTA-AUTH-JS:updateAuthState: Event:${event} Status:${status}`);\n      getConsole().log(key, token);\n      getConsole().log('Current authState', this._authState);\n      getConsole().groupEnd();\n      \n      // clear log options after logging\n      this._logOptions = {};\n    };\n\n    const emitAuthStateChange = (authState) => {\n      if (isSameAuthState(this._authState, authState)) {\n        devMode && log('unchanged'); \n        return;\n      }\n      this._authState = authState;\n      // emit new authState object\n      this._sdk.emitter.emit(EVENT_AUTH_STATE_CHANGE, { ...authState });\n      devMode && log('emitted');\n    };\n\n    const shouldEvaluateIsPending = () => !!(autoRenew || autoRemove);\n\n    if (this._pending.updateAuthStatePromise) {\n      if (this._pending.canceledTimes >= MAX_PROMISE_CANCEL_TIMES) {\n        // stop canceling then starting a new promise\n        // let existing promise finish to prevent running into loops\n        devMode && log('terminated');\n        return;\n      } else {\n        this._pending.updateAuthStatePromise.cancel();\n      }\n    }\n\n    /* eslint-disable complexity */\n    const cancelablePromise = new PCancelable((resolve, _, onCancel) => {\n      onCancel.shouldReject = false;\n      onCancel(() => {\n        this._pending.updateAuthStatePromise = null;\n        this._pending.canceledTimes = this._pending.canceledTimes + 1;\n        devMode && log('canceled');\n      });\n\n      const emitAndResolve = (authState) => {\n        if (cancelablePromise.isCanceled) {\n          resolve();\n          return;\n        }\n        // emit event and clear pending states\n        emitAuthStateChange(authState); \n        this._pending = { ...DEFAULT_PENDING };\n        resolve();\n      };\n\n      this._sdk.tokenManager.getTokens()\n        .then(({ accessToken, idToken, refreshToken }) => {\n          if (cancelablePromise.isCanceled) {\n            resolve();\n            return;\n          }\n\n          // evaluate isPending if any token is expired\n          // then wait for next renewed event to evaluate a new state with valid tokens\n          // isPending state should only apply to token driven evaluation\n          let isPending = false;\n          if (accessToken && this._sdk.tokenManager.hasExpired(accessToken)) {\n            accessToken = null;\n            isPending = shouldEvaluateIsPending();\n          }\n          if (idToken && this._sdk.tokenManager.hasExpired(idToken)) {\n            idToken = null;\n            isPending = shouldEvaluateIsPending();\n          }\n          const authState = {\n            accessToken,\n            idToken,\n            refreshToken,\n            isPending,\n            isAuthenticated: !!(accessToken && idToken)\n          };\n          const promise: Promise<AuthState> = transformAuthState\n            ? transformAuthState(this._sdk, authState)\n            : Promise.resolve(authState);\n\n          promise\n            .then(authState => emitAndResolve(authState))\n            .catch(error => emitAndResolve({\n              accessToken, \n              idToken, \n              refreshToken,\n              isAuthenticated: false, \n              isPending: false,\n              error\n            }));\n        });\n    });\n    /* eslint-enable complexity */\n    this._pending.updateAuthStatePromise = cancelablePromise;\n  }\n\n  subscribe(handler): void {\n    this._sdk.emitter.on(EVENT_AUTH_STATE_CHANGE, handler);\n  }\n\n  unsubscribe(handler?): void {\n    this._sdk.emitter.off(EVENT_AUTH_STATE_CHANGE, handler);\n  }\n}\n"],"file":"AuthStateManager.js"}